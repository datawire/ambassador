package snapshot

import (
	"github.com/datawire/ambassador/pkg/kates"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// TODO(acookin): figure out what actually needs to be removed/scrubbed here
// i think things that we can remove here are sensitive info (obviously) and redundant/unneeded info
// We probably don't need things generated by the kube server, like `lastappliedconfiguration`, for
// example. I'm not currently removing any of that server generated ish bc I'm just going to let the
// agentcom decide what it wants to store.
// It's just not currently obvious to me what other information (besides secrets) is actually
// classified as `sensitive`.
//
// Also do we need to include the Deltas from the snapshot?
// deltas just seem to be object/type metadata and an enum for the operation
//
// Is there anything super secret in snapshot.Consul? to me it seems like nah
func (s *Snapshot) Sanitize() error {
	var err error
	if err = s.Kubernetes.Sanitize(); err != nil {
		return err
	}
	// this invalid stuff could contain secret secret things probably
	// so it's probably best to scrub the contents and just send along the object meta and
	// error?
	scrubbedInvalid := []*kates.Unstructured{}
	for _, invalid := range s.Invalid {
		scrubbed := kates.NewUnstructured(invalid.GetKind(), invalid.GetAPIVersion())
		scrubbed.SetName(invalid.GetName())
		scrubbed.SetNamespace(invalid.GetNamespace())
		invalidErrs, hasErrors := invalid.Object["errors"]
		if hasErrors {
			scrubbed.SetUnstructuredContent(map[string]interface{}{
				"errors": invalidErrs,
			})
		}
	}
	s.Invalid = scrubbedInvalid
	return nil
}

func (ambInputs *AmbassadorInputs) Sanitize() error {
	// create new secrets so we only carry over info we want
	// secret values can live on in the last applied configuration annotation, for example

	// another option here is that we could have a `Sanatizable` interface, and have each object
	// that needs to be cleaned up a bit implement `Sanitize()`, but, imo, that's harder to
	// read
	sanitizedSecrets := []*kates.Secret{}
	for _, secret := range ambInputs.Secrets {
		sanitizedSecret := &kates.Secret{
			Type:     secret.Type,
			TypeMeta: secret.TypeMeta,
			ObjectMeta: metav1.ObjectMeta{
				Name:      secret.ObjectMeta.Name,
				Namespace: secret.ObjectMeta.Namespace,
			},
			Data: map[string][]byte{},
		}
		for k := range secret.Data {
			// are keys okay to add?
			sanitizedSecret.Data[k] = []byte(`<REDACTED>`)
		}
		sanitizedSecrets = append(sanitizedSecrets, sanitizedSecret)
	}

	return nil
}
